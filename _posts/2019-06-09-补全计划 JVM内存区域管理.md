---
layout: post  
title:  "补全计划| JVM内存区域管理"  
date: 2019-06-09  
description: "JVM内存区域管理"
tag: JVM
---
> 在Android开发中，我们经常会碰到OOM以及莫名闪退的情况，很大程度上导致于此的原因都是因为我们没有很好地对内存进行管理，进而导致内存泄露（如长生命周期的对象持有短生命周期对象的引用）、内存溢出的情况（如Handler的不规范写法，加载过大过多的bitmap资源）。于是有时要求程序员们进行手动GC，或使用更轻量的数据结构等方法去避免内存溢出。
> - 内存溢出（Out Of Memory）
> 指程序在申请内存时，没有足够的内存空间供其使用，出现OOM；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。
> - 内存泄露（Memory Leak）
> 指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。
> 
> **Memory Leak会最终会导致Out Of Memory**
>
>始めましょう！

@[TOC]
## 概述
对于 Java 的开发者来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个 new 操作去写配对的 delete / free 代码，这样不容易出现内存泄露和内存溢出的问题，只要全权交给虚拟机去处理。不过，也正是因为这样，一旦出现内存泄露和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会异常艰难。
所以我们只有了解了虚拟机的各个区域、各个区域的作用、服务对象等，才能在遇到内存问题时去解决这些问题。

## JVM运行时内存划分
Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间。根据 《Java 虚拟机规范》的规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域，划分如图：

![运行时数据区](https://upload-images.jianshu.io/upload_images/1034114-fa90714fb1a57b13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/536/format/webp)
运行时数据区被分为**线程私有数据区**和**线程共享数据区**两大类：
- **线程私有数据区**：程序计数器、虚拟机栈、本地方法栈
- **线程共享数据区**：Java堆、方法区（内部包含常量池）
### 程序计数器| Program Counter Register
该区域是一块较小的内存空间，它可以看作是当前线程所执行的字节码的 行号指示器。
### Java虚拟机栈| Java Virtual Machine Stacks
### 本地方法栈| Native Method Stack
### Java堆| Java Heap
### 方法区| Method Area
### 运行时常量池| Runtime Constant Pool
### 直接内存| Direct Memory
## 推荐阅读
[深入理解 Java 虚拟机  Java内存区域与内存溢出异常](https://www.jianshu.com/p/989c90f339b9)