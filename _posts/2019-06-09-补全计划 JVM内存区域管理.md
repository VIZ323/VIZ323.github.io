---
layout: post  
title:  "补全计划| JVM内存区域管理"  
date: 2019-06-09  
description: "JVM内存区域管理"
tag: JVM
---
> 在Android开发中，我们经常会碰到OOM以及莫名闪退的情况，很大程度上导致于此的原因都是因为我们没有很好地对内存进行管理，进而导致内存泄露（如长生命周期的对象持有短生命周期对象的引用）、内存溢出的情况（如Handler的不规范写法，加载过大过多的bitmap资源）。于是有时要求程序员们进行手动GC，或使用更轻量的数据结构等方法去避免内存溢出。
> - 内存溢出（Out Of Memory）
> 指程序在申请内存时，没有足够的内存空间供其使用，出现OOM；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。
> - 内存泄露（Memory Leak）
> 指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。
> 
> **Memory Leak会最终会导致Out Of Memory**
>
>始めましょう！

@[TOC]
# 概述
对于 Java 的开发者来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个 new 操作去写配对的 delete / free 代码，这样不容易出现内存泄露和内存溢出的问题，只要全权交给虚拟机去处理。不过，也正是因为这样，一旦出现内存泄露和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会异常艰难。
所以我们只有了解了虚拟机的各个区域、各个区域的作用、服务对象等，才能在遇到内存问题时去解决这些问题。

# JVM运行时内存划分
Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间。根据 《Java 虚拟机规范》的规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域，划分如图：

![JVM运行时的数据区域](https://img-blog.csdnimg.cn/20190610165436867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODk1Mzc5,size_16,color_FFFFFF,t_70)
运行时数据区被分为**线程私有数据区**和**线程共享数据区**两大类：
- **线程私有数据区**：程序计数器、虚拟机栈、本地方法栈
- **线程共享数据区**：Java堆、方法区（内部包含常量池）
## 程序计数器| Program Counter Register
### 概述
该区域是一块较小的内存空间，它可以看作是当前线程所执行的字节码的**行号指示器**。
- 如果线程正在执行的是一个**Java方法**，计数器记录的是**正在执行的虚拟机字节码指令的地址**。
- 如果正在执行的是**Native方法**，这个**计数器值则为空**。

 由于Java 虚拟机的多线程是通过 **线程轮流切换** 并 **分配处理器执行时间** 来实现的，在某一时刻，只会执行一条线程。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。
### 可能抛出的异常 
**此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。**
## Java虚拟机栈| Java Virtual Machine Stacks
### 概述
与程序计数器一样。Java虚拟机栈也是**线程私有**的，它的**生命周期与线程相同**。
虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个**栈帧**用于存储**局部变量表**、**操作数栈**、**动态链接**、**方法出口**等信息。每一个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
### 可能抛出的异常 
- 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出**StackOverflowError异常**；
- 如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可以动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），且扩展时无法申请到足够的内存，就会抛出**OutOfMemoryError异常**。
### 局部变量表
局部变量表存放了编译器可知的各种**基本数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，他不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和**return Address类型**（指向了一条字节码指令的地址）。
局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，**在方法运行期间不会改变局部变量的大小**。
## 本地方法栈| Native Method Stack
### 概述
与虚拟机栈发挥的作用相似：
- **虚拟机栈**为虚拟机执行 **Java方法（字节码）** 服务。
- **本地方法栈**为虚拟机使用到的  **Native 方法** 服务。
### 可能抛出的异常 
与虚拟机一样，本地方法栈区域也会抛出**StackOverflowError**和**OutOfMemoryError**异常。
## Java堆| Java Heap
### 概述
对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是**被所有线程共享的一块内存区域**，在**虚拟机启动时创建**。此内存区域的唯一目的就是**存放对象实例**，几乎所有的对象实例都在这里分配内存。
Java堆也是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected-Heap）。从内存回收的角度来康，由于现在收集器基本采用分代收集算法，所以Java堆中还可以细分为：**新生代**和**老年代**。从内存分配的角度来康，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。不过无论如何划分，斗鱼存放内容无关，无论哪个区域，**存储的都仍然是对象实例**，进一步划分的目的是为了**更好地回收内存**，或者**更快地分配内存**。
Java堆可以处于**物理上不连续的内存空间**中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的。
###  可能抛出的异常 
如果在堆上没有内存完成实例的分配，并且堆也无法完成再扩展时，就会抛出**OutOfMemoryError异常**。
## 方法区| Method Area
### 概述
方法区与Java堆一样，是各个**线程共享的内存区域**，它用于存储已被**虚拟机加载的类信息**、**常量**、**静态变量**、**即时编译器编译后的代码**等数据。另外，在Java虚拟机规范中，**方法区被描述为堆的一个逻辑部分**。
方法区和Java堆一样，**不需要连续的内存**和**可以选择固定大小**或者**可扩展**，并且该块区域可以选择**不实现垃圾收集**。相对而言，垃圾收集行为在这个区域是比较少出现的。该区域的内存回收目标主要是针对**常量池的回收**和**对类型的卸载**。
### 可能抛出的异常 
当方法去无法满足内存分配需求时，将抛出**OutOfMemoryError异常**。
## 运行时常量池| Runtime Constant Pool
### 概述
**运行时常量池**是**方法区的一部分**。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。
一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。
Java 语言并不要求常量池一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容后才能进入方法区的运行时常量池，运行期间也可以将新的常量放入池中，这种特性用的比较广泛的便是 String 类的 intern() 方法（延伸阅读：[Java - 记录String中intern()方法的学习与理解](https://www.cnblogs.com/aloenfs/p/9127353.html)）。

### 可能抛出的异常 
既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池**无法再申请到内存时**会抛出**OutOfMemoryError异常**。
## 直接内存| Direct Memory
### 概述
直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。
JDK 1.4 的 NIO 类可以使用 native 函数库直接分配堆外内存，这是一种基于通道与缓冲区的 I/O 方式，它在 Java 堆中存储一个 DirectByteBuffer 对象作为堆外内存的引用，这样就可以对堆外内存进行操作了。因为可以避免 Java 堆和 Native 堆之间来回复制数据，在一些场景可以带来显著的性能提高。
### 可能抛出的异常 
服务器管理员在配置 JVM 参数时，会根据机器的实际内存设置 -Xmx 等信息，但经常会忽略直接内存（默认等于 -Xmx 设置值），这可能会使得各个内存区域的总和大于物理内存限制，从而导致动态扩展时出现 **OutOfMemoryError异常**。

# HotSpot 虚拟机堆中的对象
## 对象的创建（遇到一条 new 指令时）
1. 检查这个指令的参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，先把这个类加载进内存；
2. 类加载检查通过后，虚拟机将为新对象分配内存，此时已经可以确定存储这个对象所需的内存大小；
3. 在堆中为新对象分配可用内存；
4. 将分配到的内存初始化；
5. 设置对象头中的数据；
6. 此时，从虚拟机的角度看，对象已经创建好了，但从 Java 程序的角度看，对象创建才刚刚开始，构造函数还没有执行。
在第 3 步中，在堆中为新对象分配可用内存时，会涉及到以下两个问题：

**如何在堆中为新对象划分可用的内存？**
- 指针碰撞（内存分配规整）
	- 用过的内存放一边，没用过的内存放一边，中间用一个指针分隔；
	- 分配内存的过程就是将指针向没用过的内存那边移动所需的长度；
- 空闲列表（内存分配不规整）
	- 维护一个列表，记录哪些内存块是可用的；
	- 分配内存时，从列表上选取一块足够大的空间分给对象，并更新列表上的记录；

**如何处理多线程创建对象时，划分内存的指针的同步问题？**
- 对分配内存空间的动作进行同步处理（CAS）；
- 把内存分配动作按照线程划分在不同的空间之中进行；
	- 每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）；
	- 哪个线程要分配内存就在哪个线程的 TLAB 上分配，TLAB 用完需要分配新的 TLAB 时，才需要同步锁定；
	- 通过 `-XX:+/-UseTLAB` 参数设定是否使用 TLAB。
## 对象的访问
Java 程序需要通过虚拟机栈上的 reference 数据来操作堆上的具体对象，reference 数据是一个指向对象的引用，不过如何通过这个引用定位到具体的对象，目前主要有以下两种访问方式：句柄访问和直接指针访问。

### 句柄访问
句柄访问会在 Java 堆中划分一块内存作为句柄池，每一个句柄存放着到对象实例数据和对象类型数据的指针。

优势：对象移动的时候（这在垃圾回收时十分常见）只需改变句柄池中对象实例数据的指针，不需要修改reference本身。
![对象的访问定位_句柄访问](https://img-blog.csdnimg.cn/20190610192143729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODk1Mzc5,size_16,color_FFFFFF,t_70)
### 直接指针访问
直接指针访问方式在 Java 堆对象的实例数据中存放了一个指向对象类型数据的指针，在 HotSpot 中，这个指针会被存放在对象头中。

优势：减少了一次指针定位对象实例数据的开销，速度更快。
![对象的访问定位_直接指针访问](https://img-blog.csdnimg.cn/20190610192337795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyODk1Mzc5,size_16,color_FFFFFF,t_70)

# 推荐阅读
[《深入理解 Java 虚拟机》PDF下载【仅用作交流学习】](https://blog.csdn.net/owen2335/article/details/87097537)

[深入理解 Java 虚拟机  Java内存区域与内存溢出异常](https://www.jianshu.com/p/989c90f339b9)

[深入理解 Java 虚拟机 - 阅读笔记](https://github.com/TangBean/understanding-the-jvm)